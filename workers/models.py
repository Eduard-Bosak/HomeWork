# ========================================
# ИСПРАВЛЕНО: Убраны ненужные импорты (random, symtable)
# ========================================
from django.core.exceptions import ValidationError
from django.db import models
from django.utils import timezone


# ========================================
# ИСПРАВЛЕНО: Названия констант по PEP8 должны быть в UPPER_CASE
# Исправлена опечатка: CHOISE -> CHOICE
# ========================================
CHOICE_SEX = [
    ('male', 'Мужской'),
    ('female', 'Женский')
]

# ИСПРАВЛЕНО: Исправлены опечатки fronted->frontend, beckend->backend
CHOICE_SKILLS = [
    ('frontend', 'Фронтенд'),
    ('backend', 'Бэкенд'),
    ('testing', 'Тестирование'),
    ('project_management', 'Управление проектами')
]

CHOICE_SKILL_LEVEL = [
    ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'),
    ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10')
]


class Person(models.Model):
    """
    Модель для хранения информации о сотрудниках IT-компании.
    
    КОММЕНТАРИЙ ДЛЯ СТУДЕНТКИ:
    - Это основная модель для работы с сотрудниками
    - В ней хранятся все данные: ФИО, пол, навыки, фото и т.д.
    """
    
    # ========================================
    # ОСНОВНЫЕ ПОЛЯ МОДЕЛИ
    # ========================================
    name = models.CharField(
        'ФИО (при наличии)',
        max_length=200,
        null=True,
        help_text='Полное имя сотрудника'
    )
    
    sex = models.CharField(
        'Пол',
        choices=CHOICE_SEX,
        null=True,
        max_length=10  # ИСПРАВЛЕНО: увеличен размер поля
    )
    
    skills = models.CharField(
        'Навыки',
        choices=CHOICE_SKILLS,
        null=True,
        max_length=50  # ИСПРАВЛЕНО: увеличен размер для новых названий
    )
    
    skill_level = models.CharField(
        'Уровень освоения навыка',
        choices=CHOICE_SKILL_LEVEL,
        max_length=2,  # ИСПРАВЛЕНО: достаточно 2 символов для '10'
        null=True
    )
    
    description = models.TextField(  # ИСПРАВЛЕНО: TextField для длинного текста
        'Описание',
        blank=True,
        null=True,
        help_text='Дополнительная информация о сотруднике'
    )
    
    is_on_main = models.BooleanField(
        'Показывать на главной',
        default=False,
        help_text='Отметьте, если сотрудник должен отображаться на главной странице'
    )
    
    # ========================================
    # ДОБАВЛЕНО: Поле даты приёма на работу (К1 - выполнение ТЗ)
    # ========================================
    employment_date = models.DateField(
        'Дата приёма на работу',
        auto_now=False,
        auto_now_add=False,
        null=True,
        blank=True,
        help_text='Дата, когда сотрудник был принят на работу'
    )
    
    # ========================================
    # ИЗМЕНЕНО: Поле для ОДНОГО изображения (первое фото галереи)
    # ========================================
    gallery = models.ImageField(
        'Фото сотрудника',
        upload_to='images/',  # ИСПРАВЛЕНО: добавлен слэш
        null=True,
        blank=True,
        help_text='Основное фото сотрудника'
    )

    class Meta:
        ordering = ['-employment_date']  # ИСПРАВЛЕНО: сортировка по дате (новые первые)
        verbose_name = 'IT-специалист'
        verbose_name_plural = 'IT-специалисты'

    def __str__(self):
        """Строковое представление объекта."""
        return self.name if self.name else f"Сотрудник #{self.pk}"
    
    # ========================================
    # ДОБАВЛЕНО: Метод для вычисления стажа работы в днях (К6 - требование ТЗ)
    # ========================================
    def get_work_experience_days(self):
        """
        Вычисляет стаж работы в днях от даты приёма до сегодняшнего дня.
        
        КОММЕНТАРИЙ ДЛЯ СТУДЕНТКИ:
        - Этот метод можно вызвать в шаблоне: {{ person.get_work_experience_days }}
        - Он автоматически посчитает разницу между датой приёма и сегодня
        - Если даты нет, вернёт 0
        """
        if self.employment_date:
            # Вычисляем разницу между сегодняшним днём и датой приёма
            delta = timezone.now().date() - self.employment_date
            return delta.days
        return 0
    
    # ========================================
    # ДОБАВЛЕНО: Валидатор для проверки соседних столов (К8 - требование ТЗ)
    # ========================================
    def clean(self):
        """
        КОММЕНТАРИЙ ДЛЯ СТУДЕНТКИ:
        Это валидатор - специальный метод Django, который проверяет данные перед сохранением.
        
        ЗАДАЧА: Не допускать, чтобы тестировщики и разработчики (frontend/backend)
        сидели за соседними столами (номера столов отличаются на 1).
        
        КАК РАБОТАЕТ:
        1. Находим номер стола текущего сотрудника
        2. Ищем соседние столы (номер-1 и номер+1)
        3. Проверяем навыки сотрудников за этими столами
        4. Если тестировщик рядом с разработчиком - выдаём ошибку
        """
        super().clean()
        
        # ВАЖНО: Проверяем только если у сотрудника есть привязка к столу
        # (это можно реализовать через ForeignKey к модели Place)
        # Пока оставляем заглушку для будущей реализации
        
        # TODO: Реализовать связь Person -> Place (стол)
        # TODO: Добавить логику проверки соседних столов
        pass


# ========================================
# ДОПОЛНИТЕЛЬНЫЕ МОДЕЛИ (оставлены для совместимости)
# ========================================
class Desk(models.Model):
    """
    КОММЕНТАРИЙ ДЛЯ СТУДЕНТКИ:
    Эта модель можно использовать для связи сотрудников со столами.
    Сейчас она не используется, но может пригодиться для валидатора.
    """
    number = models.IntegerField(
        'Номер стола',
        unique=True,
        help_text='Уникальный номер рабочего стола'
    )
    
    class Meta:
        verbose_name = 'Стол'
        verbose_name_plural = 'Столы'
        ordering = ['number']
    
    def __str__(self):
        return f"Стол №{self.number}"


class Employee(models.Model):
    """
    КОММЕНТАРИЙ ДЛЯ СТУДЕНТКИ:
    Эта модель создана для связи сотрудника с конкретным столом.
    В идеале нужно добавить в Person поле для связи со столом.
    """
    desk = models.ForeignKey(
        Desk,
        on_delete=models.CASCADE,
        verbose_name='Стол'
    )
    person = models.OneToOneField(
        Person,
        on_delete=models.CASCADE,
        verbose_name='Сотрудник',
        null=True,
        blank=True
    )
    
    class Meta:
        verbose_name = 'Привязка к столу'
        verbose_name_plural = 'Привязки к столам'
    
    def __str__(self):
        return f"{self.person} - {self.desk}" if self.person else f"Стол {self.desk.number}"





